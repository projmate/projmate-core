// Generated by CoffeeScript 1.6.1
(function() {
  var $, Async, Fs, Path, S, Sandbox, Utils, clone, getMeta, log, read, readProjectInput, realUri, sandbox, template, templayed, updateMeta, walkdir;

  Path = require("path");

  Async = require("async");

  S = require("string");

  Fs = require("fs");

  $ = require("projmate-shell");

  Utils = require("../common/utils");

  read = require("read");

  templayed = require("templayed");

  Sandbox = require("sandbox");

  log = require("../common/logger").getLogger("pm-create");

  walkdir = require("walkdir");

  realUri = function(url) {
    var slashes;
    slashes = (url.match(/\//g) || []).length;
    if (slashes === 1) {
      return "git@github.com/" + url + ".git";
    } else {
      return url;
    }
  };

  clone = function(url, dirname, force, cb) {
    var fetch;
    fetch = function() {
      if (url.indexOf("file://") === 0) {
        url = S(url).chompLeft("file://").ensureRight("/").s;
        log.info("Copying " + url + " to " + dirname);
        $.cp_rf(url, dirname);
      } else {
        $.exec("git clone " + url + " " + dirname);
      }
      return cb();
    };
    if (Fs.existsSync(dirname)) {
      return read({
        prompt: "Project " + dirname + " exists. Overwrite? Type yes or",
        "default": 'N'
      }, function(err, result) {
        if (result === "yes") {
          $.rm_rf(dirname);
          return fetch();
        } else {
          return cb("Project not created.");
        }
      });
    } else {
      return fetch();
    }
  };

  sandbox = new Sandbox();

  getMeta = function(source, cb) {
    source = "" + source + ";\nJSON.stringify(meta)";
    return sandbox.run(source, function(output) {
      try {
        return cb(null, JSON.parse(S(output.result).chompLeft("'").chompRight("'").s));
      } catch (ex) {
        return cb("Could not parse meta: " + ex.toString());
      }
    });
  };

  updateMeta = function(source, inputs, cb) {
    source = "" + source + ";\nvar inputs = " + (JSON.stringify(inputs)) + ";\nfor (var key in meta) {\n  if (typeof(meta[key]) === 'function') {\n    inputs[key] = meta[key].apply(inputs);\n  }\n}\nJSON.stringify(inputs)";
    return sandbox.run(source, function(output) {
      try {
        return cb(null, JSON.parse(S(output.result).chompLeft("'").chompRight("'").s));
      } catch (ex) {
        return cb("Could not parse meta: " + ex.toString());
      }
    });
  };

  readProjectInput = function(dirname, cb) {
    var meta, metaFile, projectName;
    metaFile = dirname + "/__meta.js";
    if (!Fs.existsSync(dirname + "/__meta.js")) {
      return cb("Invalid project skeleton, `__meta.js` not found");
    }
    projectName = Path.basename(dirname);
    meta = Fs.readFileSync(metaFile, "utf8");
    $.rm(metaFile);
    return getMeta(meta, function(err, inputs) {
      if (err) {
        return console.error(err);
      }
      return Async.eachSeries(Object.keys(inputs), function(key, cb) {
        var opts;
        opts = {
          prompt: "Enter " + inputs[key] + ": "
        };
        if (key === "project") {
          opts["default"] = projectName;
        }
        return read(opts, function(err, result) {
          if (err) {
            return cb(err);
          }
          if (S(result).isEmpty()) {
            return cb("All inputs are required");
          }
          inputs[key] = result;
          return cb();
        });
      }, function(err) {
        if (err) {
          return cb(err);
        }
        return updateMeta(meta, inputs, cb);
      });
    });
  };

  template = function(text, locals) {
    var key, value;
    for (key in locals) {
      value = locals[key];
      text = text.replace(new RegExp("\\{\\{" + key + "}}", "g"), value);
    }
    return text;
  };

  exports.run = function(options) {
    var dirname, fetchProject, inputs, readUserInput, updateFileAndContentTemplates, url;
    if (options == null) {
      options = {};
    }
    if (!options.url) {
      return log.error("options.url is required");
    }
    url = realUri(options.url);
    dirname = options.project || process.cwd();
    inputs = {};
    fetchProject = function(cb) {
      return clone(url, dirname, options.force, cb);
    };
    readUserInput = function(cb) {
      return readProjectInput(dirname, function(err, readInputs) {
        inputs = readInputs;
        return cb(err);
      });
    };
    updateFileAndContentTemplates = function(cb) {
      Utils.walkDirSync(dirname, true, function(dirname, subdirs, files) {
        var content, dir, file, newPath, path, _i, _j, _len, _len1, _results;
        for (_i = 0, _len = subdirs.length; _i < _len; _i++) {
          dir = subdirs[_i];
          path = Path.join(dirname, dir);
          if (dir.indexOf("{{") >= 0) {
            newPath = Path.join(dirname, template(dir, inputs));
            $.mv(path, newPath);
          }
        }
        _results = [];
        for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
          file = files[_j];
          path = Path.join(dirname, file);
          if (file.indexOf("{{") >= 0) {
            newPath = Path.join(dirname, template(file, inputs));
            $.mv(path, newPath);
          }
          if (!Utils.isFileBinary(path)) {
            content = Fs.readFileSync(path, "utf8");
            if (content.indexOf("{{") >= 0) {
              content = template(content, inputs);
              _results.push(Fs.writeFileSync(path, content));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      return cb();
    };
    return Async.series([fetchProject, readUserInput, updateFileAndContentTemplates], function(err) {
      if (err) {
        return log.error(err);
      }
      return log.info("OK");
    });
  };

}).call(this);
